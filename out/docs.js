"use strict";
function generateFontSizeCssVars(names) {
    if (names === void 0) { names = SIZES; }
    var getSizeDef = function (i) { return ({
        fontSize: 12 + i * 4,
        iconSize: 14 + i * 4,
        size: 16 + i * 8,
    }); };
    var acc = "  /* generated by generateFontSizeCssVars */";
    for (var i = 0; i < names.length; i++) {
        var name_1 = names[i];
        var _a = getSizeDef(i), fontSize = _a.fontSize, iconSize = _a.iconSize, size = _a.size;
        acc += "\n  --fontSize-".concat(name_1, ": ").concat(fontSize, "px;");
        acc += "\n  --iconSize-".concat(name_1, ": ").concat(iconSize, "px;");
        acc += "\n  --size-".concat(name_1, ": ").concat(size, "px;");
    }
    return acc;
}
function generateColorCssVars(colors, start, step, shades) {
    if (colors === void 0) { colors = BASE_COLORS; }
    if (start === void 0) { start = 0.874; }
    if (step === void 0) { step = 2; }
    if (shades === void 0) { shades = COLOR_SHADES; }
    var acc = "  /* generated by generateColorCssVars */";
    for (var _i = 0, _a = Object.entries(colors); _i < _a.length; _i++) {
        var _b = _a[_i], colorName = _b[0], color = _b[1];
        for (var i = 0; i < shades.length; i++) {
            var shadeName = shades[i];
            var shadeSuffix = shadeName ? "-".concat(shadeName) : "";
            var shadeNumber = +"".concat((shadeName || "0")[0], ".").concat(shadeName.slice(1));
            var alpha = start / Math.pow(step, shadeNumber);
            acc += "\n  --".concat(colorName).concat(shadeSuffix, ": rgba(").concat(color, ", ").concat(alpha.toFixed(3), ");");
        }
    }
    return acc;
}
setTimeout(function () {
    //console.log(generateFontSizeCssVars());
    console.log(generateColorCssVars());
});
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
// TODO: make a typescript compiler to compile packages like odin
// utils
var JSGUI_VERSION = "v0.4-dev";
function parseJsonOrNull(jsonString) {
    try {
        return JSON.parse(jsonString);
    }
    catch (_a) {
        return null;
    }
}
function camelCaseToKebabCase(key) {
    var _a;
    return ((_a = key.match(/[A-Z][a-z]*|[a-z]+/g)) !== null && _a !== void 0 ? _a : []).map(function (v) { return v.toLowerCase(); }).join("-");
}
function removePrefix(value, prefix) {
    return value.startsWith(prefix) ? value.slice(prefix.length) : value;
}
function removeSuffix(value, prefix) {
    return value.endsWith(prefix) ? value.slice(value.length - prefix.length) : value;
}
function addPx(value) {
    var _a;
    return (((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) === "Number") ? "".concat(value, "px") : value;
}
/** clamp value between min and max (defaulting to min) */
function clamp(value, min, max) {
    return Math.max(min, Math.min(value, max));
}
function getDiff(oldValue, newValue) {
    var _a, _b;
    var diffMap = {};
    for (var _i = 0, _c = Object.entries(oldValue); _i < _c.length; _i++) {
        var _d = _c[_i], k = _d[0], v = _d[1];
        var d = (_a = diffMap[k]) !== null && _a !== void 0 ? _a : { key: k };
        d.oldValue = v;
        diffMap[k] = d;
    }
    for (var _e = 0, _f = Object.entries(newValue); _e < _f.length; _e++) {
        var _g = _f[_e], k = _g[0], v = _g[1];
        var d = (_b = diffMap[k]) !== null && _b !== void 0 ? _b : { key: k };
        d.newValue = v;
        diffMap[k] = d;
    }
    return Object.values(diffMap).filter(function (v) { return v.newValue !== v.oldValue; });
}
function getDiffArray(oldValues, newValues) {
    var _a, _b;
    var diffMap = {};
    for (var _i = 0, oldValues_1 = oldValues; _i < oldValues_1.length; _i++) {
        var k = oldValues_1[_i];
        var d = (_a = diffMap[k]) !== null && _a !== void 0 ? _a : { key: k };
        d.oldValue = k;
        diffMap[k] = d;
    }
    for (var _c = 0, newValues_1 = newValues; _c < newValues_1.length; _c++) {
        var k = newValues_1[_c];
        var d = (_b = diffMap[k]) !== null && _b !== void 0 ? _b : { key: k };
        d.newValue = k;
        diffMap[k] = d;
    }
    return Object.values(diffMap).filter(function (v) { return v.newValue !== v.oldValue; });
}
// component
var Component = /** @class */ (function () {
    function Component(onRender, args, baseProps, props, options) {
        var _a;
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : onRender.name;
        if (!this.name && (options.name !== ""))
            throw "Function name cannot be empty: ".concat(onRender);
        this.args = args;
        this.baseProps = baseProps;
        this.props = props;
        this.children = [];
        this.onRender = onRender;
        this.options = options;
        // metadata
        this._ = null;
        this.key = "";
        // hooks
        this.node = null;
        this.indexedChildCount = 0;
    }
    Component.prototype.useNode = function (defaultNode) {
        var _a, _b;
        return (this.node = ((_b = (_a = this._) === null || _a === void 0 ? void 0 : _a.prevNode) !== null && _b !== void 0 ? _b : defaultNode));
    };
    Component.prototype.append = function (child) {
        this.children.push(child);
        var key = child.baseProps.key;
        if (key == null) {
            key = "".concat(child.name, "-").concat(this.indexedChildCount++);
        }
        child.key = key;
        return child;
    };
    Component.prototype.useState = function (defaultState) {
        var _ = this._;
        if (!_.stateIsInitialized) {
            _.state = defaultState;
            _.stateIsInitialized = true;
        }
        return _.state;
    };
    Component.prototype.useValidate = function (getErrors) {
        var _this = this;
        return function () {
            var errors = {};
            getErrors(errors);
            var state = _this._.state;
            state.errors = errors;
            state.didValidate = true;
            var hasErrors = Object.keys(errors).length > 0;
            if (hasErrors) {
                _this.rerender();
            }
            return !hasErrors;
        };
    };
    // dispatch
    Component.prototype.useMedia = function (mediaQuery) {
        var key = Object.entries(mediaQuery).map(function (_a) {
            var k = _a[0], v = _a[1];
            return "(".concat(camelCaseToKebabCase(k), ": ").concat(addPx(v), ")");
        }).join(' and ');
        var dispatchTarget = _dispatchTargets.media.addDispatchTarget(key);
        dispatchTarget.addComponent(this);
        return dispatchTarget.state.matches; // TODO: this forces recalculate style (4.69 ms), cache value so this doesn't happen?
    };
    Component.prototype.useLocalStorage = function (key, defaultValue) {
        var _a, _b;
        _dispatchTargets.localStorage.addComponent(this);
        var value = (_b = (_a = parseJsonOrNull(localStorage[key])) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : defaultValue;
        var setValue = function (newValue) {
            localStorage.setItem(key, JSON.stringify([newValue]));
        };
        var setValueAndDispatch = function (newValue) {
            setValue(newValue);
            if (JSON.stringify([newValue]) !== localStorage[key]) {
                _dispatchTargets.localStorage.dispatch();
            }
        };
        return [value, setValue, setValueAndDispatch];
    };
    Component.prototype.useLocationHash = function () {
        _dispatchTargets.locationHash.addComponent(this);
        return window.location.hash;
    };
    Component.prototype.useAnyScroll = function () {
        _dispatchTargets.anyScroll.addComponent(this);
    };
    Component.prototype.useWindowResize = function () {
        _dispatchTargets.windowResize.addComponent(this);
    };
    Component.prototype.useNavigate = function () {
        return {
            pushRoute: function (url) { return location.href = url; },
            replaceRoute: function (url) { return location.replace(url); },
            pushHistory: function (url) { return history.pushState(null, "", url); },
            replaceHistory: function (url) { return history.replaceState(null, "", url); },
        };
    };
    Component.prototype.rerender = function () {
        var root_ = this._.root;
        var rootComponent = root_.component;
        var newGcFlag = !root_.gcFlag;
        if (!root_.willRerenderNextFrame) {
            root_.willRerenderNextFrame = true;
            requestAnimationFrame(function () {
                var newRootComponent = _copyRootComponent(rootComponent);
                newRootComponent._ = root_;
                root_.gcFlag = newGcFlag;
                root_.component = newRootComponent;
                _render(newRootComponent, root_.parentNode);
                _unloadUnusedComponents(rootComponent, newGcFlag);
                root_.willRerenderNextFrame = false;
            });
        }
    };
    Component.prototype._findByName = function (name) {
        if (this.name === name)
            return this;
        return this.children.map(function (v) { return v._findByName(name); }).filter(function (v) { return v; })[0];
    };
    Component.prototype._logByName = function (name) {
        var _a;
        var component = this._findByName(name);
        console.log(__assign(__assign({}, (component !== null && component !== void 0 ? component : {})), { _: __assign({}, ((_a = component === null || component === void 0 ? void 0 : component._) !== null && _a !== void 0 ? _a : {})) }));
    };
    return Component;
}());
function makeComponent(onRender, options) {
    if (options === void 0) { options = {}; }
    return function () {
        var _a;
        var argsOrProps = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            argsOrProps[_i] = arguments[_i];
        }
        var argCount = Math.max(0, onRender.length - 1);
        var args = argsOrProps.slice(0, argCount);
        var propsAndBaseProps = ((_a = argsOrProps[argCount]) !== null && _a !== void 0 ? _a : {});
        var key = propsAndBaseProps.key, _b = propsAndBaseProps.style, style = _b === void 0 ? {} : _b, _c = propsAndBaseProps.attribute, attribute = _c === void 0 ? {} : _c, className = propsAndBaseProps.className, _d = propsAndBaseProps.cssVars, cssVars = _d === void 0 ? {} : _d, _e = propsAndBaseProps.events, events = _e === void 0 ? {} : _e, props = __rest(propsAndBaseProps, ["key", "style", "attribute", "className", "cssVars", "events"]);
        var baseProps = {
            key: (key != null) ? String(key) : undefined,
            style: style,
            attribute: attribute,
            className: Array.isArray(className) ? className : (className !== null && className !== void 0 ? className : "").split(" ").filter(function (v) { return v; }),
            cssVars: cssVars,
            events: events,
        };
        return new Component(onRender, args, baseProps, props, options);
    };
}
function _copyRootComponent(component) {
    var newComponent = new Component(component.onRender, component.args, component.baseProps, component.props, component.options);
    newComponent._ = component._;
    return newComponent;
}
// dispatch
var DispatchTarget = /** @class */ (function () {
    function DispatchTarget(addListeners) {
        if (addListeners === void 0) { addListeners = function () { }; }
        var _this = this;
        this.components = [];
        this.state = addListeners(function () { return _this.dispatch(); });
    }
    DispatchTarget.prototype.addComponent = function (component) {
        this.components.push(component);
    };
    DispatchTarget.prototype.removeComponent = function (component) {
        var i = this.components.indexOf(component);
        if (i !== -1)
            this.components.splice(i, 1);
    };
    DispatchTarget.prototype.dispatch = function () {
        for (var _i = 0, _a = this.components; _i < _a.length; _i++) {
            var component = _a[_i];
            component.rerender();
        }
    };
    return DispatchTarget;
}());
var DispatchTargetMap = /** @class */ (function () {
    function DispatchTargetMap(addListeners) {
        this.data = {};
        this.addListeners = addListeners;
    }
    DispatchTargetMap.prototype.addDispatchTarget = function (key) {
        var _a = this, data = _a.data, addListeners = _a.addListeners;
        var oldDT = data[key];
        if (oldDT != null)
            return oldDT;
        var newDT = new DispatchTarget(addListeners(key));
        data[key] = newDT;
        return newDT;
    };
    DispatchTargetMap.prototype.removeComponent = function (component) {
        for (var key in this.data) {
            this.data[key].removeComponent(component);
        }
    };
    return DispatchTargetMap;
}());
var _dispatchTargets = {
    media: new DispatchTargetMap(function (key) { return function (dispatch) {
        var mediaQueryList = window.matchMedia(key);
        mediaQueryList.addEventListener("change", dispatch);
        return mediaQueryList;
    }; }),
    localStorage: new DispatchTarget(function (dispatch) { return window.addEventListener("storage", dispatch); }),
    locationHash: new DispatchTarget(function (dispatch) {
        window.addEventListener("hashchange", function () {
            _scrollToLocationHash();
            dispatch();
        });
    }),
    anyScroll: new DispatchTarget(),
    windowResize: new DispatchTarget(function (dispatch) { return window.addEventListener("resize", dispatch); }),
    removeComponent: function (component) {
        _dispatchTargets.media.removeComponent(component);
        _dispatchTargets.localStorage.removeComponent(component);
        _dispatchTargets.locationHash.removeComponent(component);
        _dispatchTargets.anyScroll.removeComponent(component);
        _dispatchTargets.windowResize.removeComponent(component);
    },
};
function _scrollToLocationHash() {
    var element = document.getElementById(location.hash.slice(1));
    if (element)
        element.scrollIntoView();
}
// metadata
var ComponentMetadata = /** @class */ (function () {
    function ComponentMetadata(parent) {
        var _a;
        // state
        this.stateIsInitialized = false;
        this.state = {};
        this.prevState = null;
        this.prevNode = null;
        this.prevBaseProps = _START_BASE_PROPS;
        this.prevEvents = {};
        this.gcFlag = false;
        // navigation
        this.prevComponent = null;
        this.keyToChild = {};
        this.prevIndexedChildCount = null;
        this.parent = parent;
        this.root = (_a = parent === null || parent === void 0 ? void 0 : parent.root) !== null && _a !== void 0 ? _a : null;
    }
    return ComponentMetadata;
}());
var RootComponentMetadata = /** @class */ (function (_super) {
    __extends(RootComponentMetadata, _super);
    function RootComponentMetadata(component, parentNode) {
        var _this = _super.call(this, null) || this;
        _this.willRerenderNextFrame = false;
        _this.root = _this;
        _this.component = component;
        _this.parentNode = parentNode;
        return _this;
    }
    return RootComponentMetadata;
}(ComponentMetadata));
// render
function renderRoot(rootComponent, parentNode) {
    if (parentNode === void 0) { parentNode = null; }
    var root_ = new RootComponentMetadata(rootComponent, parentNode);
    rootComponent._ = root_;
    window.onload = function () {
        var _a;
        root_.parentNode = (_a = root_.parentNode) !== null && _a !== void 0 ? _a : document.body;
        _computeScrollbarWidth();
        _render(rootComponent, root_.parentNode);
        requestAnimationFrame(function () {
            _scrollToLocationHash();
        });
    };
}
var _START_BASE_PROPS = {
    attribute: {},
    className: [],
    cssVars: {},
    style: {},
};
function _render(component, parentNode, _inheritedBaseProps, isTopNode) {
    var _a, _b, _c, _d;
    if (_inheritedBaseProps === void 0) { _inheritedBaseProps = _START_BASE_PROPS; }
    if (isTopNode === void 0) { isTopNode = true; }
    // render elements
    var _ = component._, name = component.name, args = component.args, baseProps = component.baseProps, props = component.props, onRender = component.onRender, _indexedChildCount = component.indexedChildCount;
    var onMount = ((_a = onRender.bind(component).apply(void 0, __spreadArray(__spreadArray([], args, false), [props], false))) !== null && _a !== void 0 ? _a : {}).onMount;
    var node = component.node;
    // warn if missing keys
    var prevIndexedChildCount = _.prevIndexedChildCount;
    if (prevIndexedChildCount !== null && (_indexedChildCount !== prevIndexedChildCount)) {
        console.warn("Varying children should have a \"key\" prop. (".concat(prevIndexedChildCount, " -> ").concat(_indexedChildCount, ")"), _.prevComponent, component);
    }
    // inherit
    var inheritedBaseProps = {
        attribute: __assign(__assign({}, _inheritedBaseProps.attribute), baseProps.attribute),
        className: __spreadArray(__spreadArray([], _inheritedBaseProps.className, true), baseProps.className, true),
        cssVars: __assign(__assign({}, _inheritedBaseProps.cssVars), baseProps.cssVars),
        style: __assign(__assign({}, _inheritedBaseProps.style), baseProps.style),
    };
    // append
    var prevNode = _.prevNode;
    if (node) {
        if (prevNode) {
            var prevName = (_b = _.prevComponent) === null || _b === void 0 ? void 0 : _b.name;
            if (name !== prevName) {
                prevNode.replaceWith(node);
                _.prevEvents = {};
            }
        }
        else {
            parentNode.append(node);
            node.addEventListener("scroll", function () {
                _dispatchTargets.anyScroll.dispatch();
            }, { passive: true });
        }
        // style
        var styleDiff = getDiff(_.prevBaseProps.style, inheritedBaseProps.style);
        for (var _i = 0, styleDiff_1 = styleDiff; _i < styleDiff_1.length; _i++) {
            var _e = styleDiff_1[_i], key = _e.key, newValue = _e.newValue;
            if (newValue != null) {
                node.style[key] = addPx(newValue);
            }
            else {
                node.style.removeProperty(key);
            }
        }
        // cssVars
        var cssVarsDiff = getDiff(_.prevBaseProps.cssVars, inheritedBaseProps.cssVars);
        for (var _f = 0, cssVarsDiff_1 = cssVarsDiff; _f < cssVarsDiff_1.length; _f++) {
            var _g = cssVarsDiff_1[_f], key = _g.key, newValue = _g.newValue;
            if (newValue != null) {
                node.style.setProperty("--".concat(key), addPx(newValue));
            }
            else {
                node.style.removeProperty("--".concat(key));
            }
        }
        // class
        if (name !== node.tagName.toLowerCase()) {
            inheritedBaseProps.className.push(name);
        }
        ;
        var classNameDiff = getDiffArray(_.prevBaseProps.className, inheritedBaseProps.className);
        for (var _h = 0, classNameDiff_1 = classNameDiff; _h < classNameDiff_1.length; _h++) {
            var _j = classNameDiff_1[_h], key = _j.key, newValue = _j.newValue;
            if (newValue != null) {
                if (key === "")
                    console.warn("className cannot be empty,", name, inheritedBaseProps.className);
                if (key.includes(" "))
                    console.warn("className cannot contain whitespace,", name, inheritedBaseProps.className);
                node.classList.add(key);
            }
            else {
                node.classList.remove(key);
            }
        }
        // attribute
        var attributeDiff = getDiff(_.prevBaseProps.attribute, inheritedBaseProps.attribute);
        for (var _k = 0, attributeDiff_1 = attributeDiff; _k < attributeDiff_1.length; _k++) {
            var _l = attributeDiff_1[_k], key = _l.key, newValue = _l.newValue;
            if (newValue != null) {
                node.setAttribute(camelCaseToKebabCase(key), String(newValue));
            }
            else {
                node.removeAttribute(camelCaseToKebabCase(key));
            }
        }
        // events
        var eventsDiff = getDiff(_.prevEvents, (_c = baseProps.events) !== null && _c !== void 0 ? _c : {});
        for (var _m = 0, eventsDiff_1 = eventsDiff; _m < eventsDiff_1.length; _m++) {
            var _o = eventsDiff_1[_m], key = _o.key, oldValue = _o.oldValue, newValue = _o.newValue;
            node.removeEventListener(key, oldValue);
            if (newValue) {
                node.addEventListener(key, newValue); // TODO: passive events?
            }
        }
        parentNode = node;
        inheritedBaseProps = _START_BASE_PROPS;
        isTopNode = false;
    }
    else {
        if (prevNode) {
            prevNode.remove(); // NOTE: removing components is handled by _unloadUnusedComponents()
            _.prevNode = null;
            _.prevBaseProps = _START_BASE_PROPS;
        }
        if (name)
            inheritedBaseProps.className.push(name); // NOTE: fragment has name: ''
    }
    // children
    var usedKeys = new Set();
    for (var _p = 0, _q = component.children; _p < _q.length; _p++) {
        var child = _q[_p];
        var key = child.key;
        if (usedKeys.has(key))
            console.warn("Duplicate key: '".concat(key, "'"), component);
        usedKeys.add(key);
        var child_ = (_d = _.keyToChild[key]) !== null && _d !== void 0 ? _d : new ComponentMetadata(_);
        _.keyToChild[key] = child_;
        child._ = child_;
        child_.gcFlag = _.gcFlag;
        _render(child, parentNode, inheritedBaseProps, isTopNode);
    }
    // on mount
    if (onMount)
        onMount(_.prevNode != null);
    _.prevNode = node;
    _.prevBaseProps = inheritedBaseProps;
    _.prevIndexedChildCount = _indexedChildCount;
    _.prevState = __assign({}, _.state);
    _.prevComponent = component;
}
// rerender
function _unloadUnusedComponents(prevComponent, rootGcFlag) {
    var _a;
    for (var _i = 0, _b = prevComponent.children; _i < _b.length; _i++) {
        var child = _b[_i];
        var child_ = child._;
        if (child_.gcFlag !== rootGcFlag) {
            _dispatchTargets.removeComponent(prevComponent);
            var key = child.key;
            (_a = child_.parent) === null || _a === void 0 ? true : delete _a.keyToChild[key];
            var prevNode = child_.prevNode;
            if (prevNode)
                prevNode.remove();
        }
        _unloadUnusedComponents(child, rootGcFlag);
    }
}
// basic components
var fragment = makeComponent(function fragment(_props) {
    if (_props === void 0) { _props = {}; }
}, { name: '' });
var div = makeComponent(function div(_props) {
    if (_props === void 0) { _props = {}; }
    this.useNode(document.createElement('div'));
});
var SIZES = ["small", "normal", "big", "bigger"];
var BASE_COLORS = {
    gray: "0, 0, 0",
    secondary: "20, 80, 160",
    red: "200, 50, 50",
};
var COLOR_SHADES = ["", "033", "067", "1", "2", "250", "3"]; // TODO: use linear colors
var span = makeComponent(function _span(text, props) {
    if (props === void 0) { props = {}; }
    var iconName = props.iconName, size = props.size, color = props.color, singleLine = props.singleLine, fontFamily = props.fontFamily, href = props.href, navigate = props.navigate, id = props.id, selfLink = props.selfLink, onClick = props.onClick;
    if (selfLink != null) {
        var selfLinkWrapper = this.append(div({ className: "selfLink", attribute: { id: id == null ? selfLink : id } }));
        selfLinkWrapper.append(span(text, __assign(__assign({}, props), { selfLink: undefined })));
        selfLinkWrapper.append(icon("tag", { size: "normal", href: "#".concat(selfLink) }));
        return;
    }
    var isLink = (href != null);
    var e = this.useNode(document.createElement(isLink ? 'a' : 'span'));
    var _a = this.baseProps, attribute = _a.attribute, className = _a.className, style = _a.style;
    if (id)
        attribute.id = id;
    if (size)
        attribute.dataSize = size;
    if (iconName)
        className.push("material-symbols-outlined");
    if (color)
        style.color = "var(--".concat(color, ")"); // TODO: remove style?
    if (singleLine)
        className.push("ellipsis");
    if (fontFamily)
        style.fontFamily = "var(--fontFamily-".concat(fontFamily, ")"); // TODO: remove style?
    if (isLink)
        e.href = href;
    navigate = (navigate !== null && navigate !== void 0 ? navigate : this.useNavigate().pushRoute);
    if (onClick || href) {
        if (!isLink) {
            attribute.tabindex = "-1";
            attribute.clickable = "true";
        }
        e.onclick = function (event) {
            if (onClick)
                onClick(event);
            if (href) {
                event.preventDefault();
                navigate(href);
            }
        };
    }
    e.innerText = iconName || (text == null ? "" : String(text)); // TODO: don't change innerText if equal?
}, { name: "span" });
var icon = makeComponent(function icon(iconName, props) {
    if (props === void 0) { props = {}; }
    var size = props.size, _a = props.style, style = _a === void 0 ? {} : _a, extraProps = __rest(props, ["size", "style"]);
    this.baseProps.attribute.dataIcon = iconName;
    this.append(span("", __assign({ iconName: iconName, size: size, style: style }, extraProps)));
});
var loadingSpinner = makeComponent(function loadingSpinner(props) {
    if (props === void 0) { props = {}; }
    this.append(icon("progress_activity", props));
});
var htmlLegend = makeComponent(function htmlLegend(text, _props) {
    if (_props === void 0) { _props = {}; }
    var node = this.useNode(document.createElement("legend"));
    node.innerText = text;
    this.baseProps.className.push("ellipsis");
}, {
    name: "legend",
});
var dialog = makeComponent(function dialog(props) {
    var open = props.open, onClose = props.onClose, closeOnClickBackdrop = props.closeOnClickBackdrop, isPopover = props.isPopover;
    var state = this.useState({ prevOpen: false });
    var e = this.useNode(document.createElement("dialog"));
    e.onclick = function (event) {
        if (closeOnClickBackdrop && (event.target === e))
            onClose();
    };
    return {
        onMount: function () {
            if (open !== state.prevOpen) {
                if (open) {
                    if (isPopover) {
                        e.show();
                    }
                    else {
                        e.showModal();
                    }
                }
                else {
                    e.close();
                }
                state.prevOpen = open;
            }
        },
    };
});
var SCROLLBAR_WIDTH = 0;
function _computeScrollbarWidth() {
    if (SCROLLBAR_WIDTH)
        return;
    var e = document.createElement("div");
    e.style.cssText = "overflow:scroll; visibility:hidden; position:absolute;";
    document.body.append(e);
    SCROLLBAR_WIDTH = e.offsetWidth - e.clientWidth;
    e.remove();
}
var popupWrapper = makeComponent(function popupWrapper(props) {
    var _this = this;
    var popupContent = props.popupContent, _a = props.direction, direction = _a === void 0 ? "up" : _a;
    var state = this.useState({
        open: false,
        mousePos: [0, 0],
    });
    var wrapper = this.useNode(document.createElement("div"));
    if (state.open)
        console.log('ayaya.state', state);
    wrapper.onmouseenter = function () {
        state.open = true;
        _this.rerender();
    };
    if (direction === "mouse") {
        wrapper.onmousemove = function (event) {
            state.mousePos = [event.clientX, event.clientY];
            _this.rerender();
        };
    }
    var onClose = function () {
        state.open = false;
        _this.rerender();
    };
    wrapper.onmouseleave = onClose;
    var popup = this.append(dialog({
        open: true,
        onClose: onClose,
        isPopover: true,
        className: "popup",
        attribute: { dataShow: state.open, dataMouse: direction === "mouse" },
    }));
    var popupContentWrapper = popup.append(div({ className: "popupContentWrapper" }));
    popupContentWrapper.append(popupContent);
    var getTopLeft = function (wrapperRect, popupRect) {
        switch (direction) {
            case "up":
                return [
                    0.5 * (wrapperRect.width - popupRect.width),
                    -popupRect.height
                ];
            case "right":
                return [
                    wrapperRect.width,
                    0.5 * (wrapperRect.height - popupRect.height)
                ];
            case "down":
                return [
                    0.5 * (wrapperRect.width - popupRect.width),
                    wrapperRect.height
                ];
            case "left":
                return [
                    -popupRect.width,
                    0.5 * (wrapperRect.height - popupRect.height)
                ];
            case "mouse":
                return [
                    state.mousePos[0] - wrapperRect.left,
                    state.mousePos[1] - wrapperRect.top - popupRect.height
                ];
        }
    };
    var getAbsoluteTopLeft = function (wrapperRect, left, top) {
        return {
            absoluteTop: wrapperRect.top + top,
            absoluteRight: wrapperRect.right + left,
            absoluteBottom: wrapperRect.bottom + top,
            absoluteLeft: wrapperRect.left + left,
        };
    };
    var getTopLeftWithFlip = function (wrapperRect, popupRect) {
        var _a, _b, _c, _d;
        var _e = getTopLeft(wrapperRect, popupRect), left = _e[0], top = _e[1];
        var windowRight = window.innerWidth;
        var windowBottom = window.innerHeight;
        switch (direction) {
            case "up": {
                var absoluteTop = getAbsoluteTopLeft(wrapperRect, left, top).absoluteTop;
                if (absoluteTop < 0) {
                    direction = "down";
                    _a = getTopLeft(wrapperRect, popupRect), left = _a[0], top = _a[1];
                }
            }
            case "down": {
                var absoluteBottom = getAbsoluteTopLeft(wrapperRect, left, top).absoluteBottom;
                if (absoluteBottom >= windowBottom) {
                    direction = "down";
                    _b = getTopLeft(wrapperRect, popupRect), left = _b[0], top = _b[1];
                }
                break;
            }
            case "left": {
                var absoluteLeft = getAbsoluteTopLeft(wrapperRect, left, top).absoluteLeft;
                if (absoluteLeft >= 0) {
                    direction = "right";
                    _c = getTopLeft(wrapperRect, popupRect), left = _c[0], top = _c[1];
                }
                break;
            }
            case "right": {
                var absoluteRight = getAbsoluteTopLeft(wrapperRect, left, top).absoluteRight;
                if (absoluteRight >= windowRight) {
                    direction = "left";
                    _d = getTopLeft(wrapperRect, popupRect), left = _d[0], top = _d[1];
                }
                break;
            }
        }
        return [left, top];
    };
    var getTopLeftWithFlipAndClamp = function (wrapperRect, popupRect) {
        var _a = getTopLeftWithFlip(wrapperRect, popupRect), left = _a[0], top = _a[1];
        var windowRight = window.innerWidth;
        var windowBottom = window.innerHeight;
        switch (direction) {
            case "up":
            case "down":
            case "mouse": {
                var minLeft = -wrapperRect.left;
                var maxLeft = windowRight - wrapperRect.left - popupRect.width - SCROLLBAR_WIDTH;
                if (state.open)
                    console.log("ayaya.clamp.1", left, minLeft, maxLeft);
                left = clamp(left, minLeft, maxLeft);
                if (state.open)
                    console.log("ayaya.clamp.2", left);
                break;
            }
        }
        switch (direction) {
            case "left":
            case "right":
            case "mouse": {
                var minTop = -wrapperRect.top;
                var maxTop = windowBottom - wrapperRect.top - popupRect.height - SCROLLBAR_WIDTH;
                top = clamp(top, minTop, maxTop);
                break;
            }
        }
        return [left, top];
    };
    return {
        onMount: function () {
            var popupNode = popup._.prevNode;
            var popupContentWrapperNode = popupContentWrapper._.prevNode;
            var wrapperRect = wrapper.getBoundingClientRect();
            var popupRect = popupContentWrapperNode.getBoundingClientRect();
            var _a = getTopLeftWithFlipAndClamp(wrapperRect, popupRect), left = _a[0], top = _a[1];
            popupNode.style.left = addPx(left);
            popupNode.style.top = addPx(top);
        }
    };
});
// inputs
var button = makeComponent(function button(text, props) {
    if (props === void 0) { props = {}; }
    var size = props.size, color = props.color, onClick = props.onClick, disabled = props.disabled;
    var e = this.useNode(document.createElement("button"));
    if (text)
        this.append(span(text));
    var attribute = this.baseProps.attribute;
    if (size)
        attribute.dataSize = size;
    if (color)
        attribute.dataColor = color;
    if (disabled)
        attribute.disabled = "true";
    else if (onClick) {
        e.onclick = onClick;
    }
});
var input = makeComponent(function input(props) {
    var _a = props.type, type = _a === void 0 ? "text" : _a, placeholder = props.placeholder, value = props.value, autoFocus = props.autoFocus, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown = props.onKeyDown, onInput = props.onInput, onChange = props.onChange, allowChar = props.allowChar, _b = props.allowString, allowString = _b === void 0 ? function (value, _prevAllowedValue) { return value; } : _b;
    var state = this.useState({ prevAllowedValue: String(value !== null && value !== void 0 ? value : '') });
    var e = this.useNode(document.createElement('input'));
    e.type = type;
    if (placeholder)
        e.placeholder = placeholder;
    if (autoFocus)
        e.autofocus = true;
    if (value != null)
        e.value = String(value);
    e.onfocus = onFocus;
    e.onblur = onBlur;
    e.onkeydown = onKeyDown;
    e.oninput = function (_event) {
        var event = _event;
        if (allowChar && "data" in event) {
            if ((event.data !== null) && !allowChar(event.data)) {
                event.preventDefault();
                event.stopPropagation();
                e.value = state.prevAllowedValue;
                return;
            }
        }
        var allowedValue = allowString(e.value, state.prevAllowedValue);
        state.prevAllowedValue = allowedValue;
        if (allowedValue === e.value) {
            if (onInput)
                onInput(allowedValue, event);
        }
    };
    e.onchange = function (event) {
        var allowedValue = allowString(e.value, state.prevAllowedValue);
        state.prevAllowedValue = allowedValue;
        if (e.value === allowedValue) {
            if (onChange)
                onChange(e.value, event);
        }
        else {
            e.value = allowedValue;
        }
    };
});
var labeledInput = makeComponent(function labeledInput(props) {
    var _a = props.label, label = _a === void 0 ? "" : _a, leftComponent = props.leftComponent, inputComponent = props.inputComponent, rightComponent = props.rightComponent;
    var fieldset = this.useNode(document.createElement("fieldset"));
    fieldset.onmousedown = function (_event) {
        var event = _event;
        if (event.target !== inputComponent._.prevNode) {
            event.preventDefault();
        }
    };
    fieldset.onclick = function (_event) {
        var event = _event;
        var prevNode = inputComponent._.prevNode;
        if (prevNode && (event.target !== prevNode)) {
            prevNode.focus();
        }
    };
    this.append(htmlLegend(label));
    if (leftComponent)
        this.append(leftComponent);
    this.append(inputComponent);
    if (rightComponent)
        this.append(rightComponent);
});
var errorMessage = makeComponent(function errorMessage(error, props) {
    if (props === void 0) { props = {}; }
    this.append(span(error, __assign({ color: "red", size: "small" }, props)));
});
var textInput = makeComponent(function textInput(props) {
    var label = props.label, leftComponent = props.leftComponent, rightComponent = props.rightComponent, error = props.error, extraProps = __rest(props, ["label", "leftComponent", "rightComponent", "error"]);
    this.append(labeledInput({
        label: label,
        leftComponent: leftComponent,
        inputComponent: input(extraProps),
        rightComponent: rightComponent,
    }));
    if (error)
        this.append(errorMessage(error));
});
var numberArrows = makeComponent(function numberArrows(props) {
    if (props === void 0) { props = {}; }
    var onClickUp = props.onClickUp, onClickDown = props.onClickDown;
    this.useNode(document.createElement("div"));
    this.append(icon("arrow_drop_up", { size: "small", onClick: onClickUp }));
    this.append(icon("arrow_drop_down", { size: "small", onClick: onClickDown }));
});
var numberInput = makeComponent(function numberInput(props) {
    var label = props.label, leftComponent = props.leftComponent, customRightComponent = props.rightComponent, error = props.error, // labeledInput
    value = props.value, min = props.min, max = props.max, step = props.step, stepPrecision = props.stepPrecision, _a = props.clearable, clearable = _a === void 0 ? true : _a, onKeyDown = props.onKeyDown, onInput = props.onInput, onChange = props.onChange, extraProps = __rest(props, ["label", "leftComponent", "rightComponent", "error", "value", "min", "max", "step", "stepPrecision", "clearable", "onKeyDown", "onInput", "onChange"]) // numberInput
    ;
    var stepAndClamp = function (number) {
        var _a;
        if (step) {
            var stepOffset = (_a = min !== null && min !== void 0 ? min : max) !== null && _a !== void 0 ? _a : 0;
            number = stepOffset + Math.round((number - stepOffset) / step) * step;
        }
        number = Math.min(number, max !== null && max !== void 0 ? max : 1 / 0);
        number = Math.max(min !== null && min !== void 0 ? min : -1 / 0, number);
        var defaultStepPrecision = step ? String(step).split(".")[1].length : 0;
        return number.toFixed(stepPrecision !== null && stepPrecision !== void 0 ? stepPrecision : defaultStepPrecision);
    };
    var incrementValue = function (by) {
        var number = stepAndClamp(+(value !== null && value !== void 0 ? value : 0) + by);
        var newValue = String(number);
        if (onInput)
            onInput(newValue, undefined);
        if (onChange)
            onChange(newValue, undefined);
    };
    var inputComponent = input(__assign(__assign({ value: value, onKeyDown: function (event) {
            switch (event.key) {
                case "ArrowUp":
                    incrementValue(step !== null && step !== void 0 ? step : 1);
                    break;
                case "ArrowDown":
                    incrementValue(-(step !== null && step !== void 0 ? step : 1));
                    break;
            }
            if (onKeyDown)
                onKeyDown(event);
        }, onInput: onInput, onChange: onChange }, extraProps), { allowChar: function (c) { return "-0123456789".includes(c); }, allowString: function (value, prevAllowedValue) {
            if (value === "")
                return clearable ? "" : prevAllowedValue;
            var number = +value;
            if (isNaN(number))
                return prevAllowedValue;
            return String(stepAndClamp(number));
        } }));
    var rightComponent = fragment();
    if (customRightComponent)
        rightComponent.append(customRightComponent);
    rightComponent.append(numberArrows({
        onClickUp: function (_event) {
            incrementValue(step !== null && step !== void 0 ? step : 1);
            inputComponent._.state.needFocus = true;
            inputComponent.rerender();
        },
        onClickDown: function (_event) {
            incrementValue(-(step !== null && step !== void 0 ? step : 1));
            inputComponent._.state.needFocus = true;
            inputComponent.rerender();
        },
    }));
    this.append(labeledInput({
        label: label,
        leftComponent: leftComponent,
        inputComponent: inputComponent,
        rightComponent: rightComponent,
    }));
    if (error)
        this.append(errorMessage(error));
});
var table = makeComponent(function table(props) {
    // TODO: set minHeight to fit N rows
    // TODO: actions, filters, search, paging, selection
    var label = props.label, _a = props.columns, columns = _a === void 0 ? [] : _a, _b = props.rows, rows = _b === void 0 ? [] : _b, _c = props.isLoading, isLoading = _c === void 0 ? false : _c, _d = props.minHeight, minHeight = _d === void 0 ? 400 : _d, _e = props.useMaxHeight, useMaxHeight = _e === void 0 ? false : _e;
    var tableWrapper = this.append(div({
        attribute: { useMaxHeight: useMaxHeight, isLoading: isLoading },
        style: { minHeight: minHeight },
    }));
    var makeRow = function (className, key) { return div({ className: className, key: key }); };
    var makeCell = function (column) {
        var _a;
        return div({
            className: "tableCell",
            style: { flex: String((_a = column.flex) !== null && _a !== void 0 ? _a : 1), minWidth: column.minWidth, maxWidth: column.maxWidth },
        });
    };
    if (label) {
        tableWrapper.append(span(label, { className: "tableLabel" }));
    }
    if (isLoading) {
        tableWrapper.append(loadingSpinner());
    }
    else {
        var headerWrapper = tableWrapper.append(makeRow("tableRow tableHeader", "header"));
        for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
            var column = columns[columnIndex];
            var cellWrapper = headerWrapper.append(makeCell(column));
            cellWrapper.append(span(column.label));
        }
        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            var row = rows[rowIndex];
            var rowWrapper = tableWrapper.append(makeRow("tableRow tableBody", "row-".concat(rowIndex)));
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                var column = columns[columnIndex];
                var cellWrapper = rowWrapper.append(makeCell(column));
                cellWrapper.append(column.onRender({ row: row, rowIndex: rowIndex, column: column, columnIndex: columnIndex }));
            }
        }
    }
});
var router = makeComponent(function router(props) {
    var _a, _b, _c;
    var routes = props.routes, _d = props.pageWrapperComponent, pageWrapperComponent = _d === void 0 ? function () { return fragment(); } : _d, _e = props.contentWrapperComponent, contentWrapperComponent = _e === void 0 ? function () { return div({ className: "pageContent" }); } : _e, currentRoles = props.currentRoles, isLoggedIn = props.isLoggedIn, _f = props.notLoggedInRoute, notLoggedInRoute = _f === void 0 ? { component: fragment } : _f, _g = props.notFoundRoute, notFoundRoute = _g === void 0 ? { component: function () { return span("404 Not found"); } } : _g, _h = props.unauthorizedRoute, unauthorizedRoute = _h === void 0 ? { component: fragment } : _h;
    var currentPath = location.pathname;
    if (currentPath.endsWith("/index.html"))
        currentPath = currentPath.slice(0, -10);
    var currentRoute = null, params = {}; // TODO: save params in rootComponent?
    var _loop_1 = function (route) {
        var regex = route.path.replace(/:([^/]+)/g, function (_match, g1) { return "(?<".concat(g1, ">[^/]*)"); });
        var match = currentPath.match(new RegExp("^".concat(regex, "$")));
        if (match != null) {
            params = (_a = match.groups) !== null && _a !== void 0 ? _a : {};
            var roles_1 = (_b = route.roles) !== null && _b !== void 0 ? _b : [];
            var needSomeRole = (roles_1.length > 0);
            var haveSomeRole = (currentRoles !== null && currentRoles !== void 0 ? currentRoles : []).some(function (role) { return roles_1.includes(role); });
            if (!needSomeRole || haveSomeRole) {
                currentRoute = route;
            }
            else {
                currentRoute = __assign({ path: ".*" }, (isLoggedIn ? notLoggedInRoute : unauthorizedRoute));
            }
            return "break";
        }
    };
    for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {
        var route = routes_1[_i];
        var state_1 = _loop_1(route);
        if (state_1 === "break")
            break;
    }
    if (!currentRoute) {
        console.warn("Route '".concat(currentPath, "' not found."));
        currentRoute = __assign({ path: ".*" }, notFoundRoute);
    }
    if (currentRoute) {
        if ((_c = currentRoute.wrapper) !== null && _c !== void 0 ? _c : true) {
            this.append(pageWrapperComponent({ routes: routes, currentRoute: currentRoute, contentWrapperComponent: contentWrapperComponent }));
        }
        else {
            var contentWrapper = this.append(contentWrapperComponent());
            contentWrapper.append(currentRoute.component());
        }
    }
});
/*
TODO: documentation
  router()
  validation api
    const validate = this.useValidate((errors) => {
      if (state.username.length < 4) errors.username = "Username must have at least 4 characters."
    });
    const onSubmit = () => {
      if (validate()) {
        // ...
      }
    }
  useLocalStorage()
  useNavigate()
*/
// TODO: more input components (icon button, radio, checkbox/switch, select, date/date range input, file input)
// TODO: badgeWrapper
// TODO: snackbar api
// https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-line-clamp ?
function getSizeLabel(size) {
    return size[0].toUpperCase() + size.slice(1);
}
var spanSection = makeComponent(function spanSection() {
    for (var _i = 0, _a = [undefined, "https://www.google.com"]; _i < _a.length; _i++) {
        var href = _a[_i];
        var row = this.append(div({ className: "displayRow", style: { marginTop: -4, marginBottom: href ? 4 : 0 } }));
        row.append(span("Small", { size: "small", href: href }));
        row.append(span("Normal", { size: "normal", href: href }));
        row.append(span("Big", { size: "big", href: href }));
        row.append(span("Bigger", { size: "bigger", href: href }));
    }
    for (var _b = 0, _c = Object.keys(BASE_COLORS); _b < _c.length; _b++) {
        var baseColor = _c[_b];
        var row = this.append(div({ className: "displayRow" }));
        for (var _d = 0, COLOR_SHADES_1 = COLOR_SHADES; _d < COLOR_SHADES_1.length; _d++) {
            var shade = COLOR_SHADES_1[_d];
            var color = shade ? "".concat(baseColor, "-").concat(shade) : baseColor;
            row.append(span(color, { color: color }));
        }
    }
});
var buttonSection = makeComponent(function buttonSection() {
    var row = this.append(div({ className: "displayRow", style: { marginTop: -4 } }));
    for (var _i = 0, SIZES_1 = SIZES; _i < SIZES_1.length; _i++) {
        var size = SIZES_1[_i];
        row.append(button(getSizeLabel(size), { size: size }));
    }
    row = this.append(div({ className: "displayRow", style: { marginTop: 4 } }));
    for (var _a = 0, SIZES_2 = SIZES; _a < SIZES_2.length; _a++) {
        var size = SIZES_2[_a];
        row.append(button(getSizeLabel(size), { color: "secondary", size: size }));
    }
    row = this.append(div({ className: "displayRow", style: { marginTop: 4 } }));
    for (var _b = 0, SIZES_3 = SIZES; _b < SIZES_3.length; _b++) {
        var size = SIZES_3[_b];
        row.append(button("Disabled", { disabled: true, size: size }));
    }
});
var iconSection = makeComponent(function spanSection() {
    var row = this.append(div({ className: "displayRow", style: { marginTop: -4 } }));
    for (var _i = 0, SIZES_4 = SIZES; _i < SIZES_4.length; _i++) {
        var size = SIZES_4[_i];
        row.append(icon("link", { size: size }));
    }
    row = this.append(div({ className: "displayRow", style: { marginTop: -4 } }));
    for (var _a = 0, SIZES_5 = SIZES; _a < SIZES_5.length; _a++) {
        var size = SIZES_5[_a];
        row.append(loadingSpinner({ size: size }));
    }
    row = this.append(div({ className: "displayRow", style: { marginTop: -4 } }));
    for (var _b = 0, SIZES_6 = SIZES; _b < SIZES_6.length; _b++) {
        var size = SIZES_6[_b];
        var buttonWrapper = row.append(button("", { size: size, color: "secondary" }));
        buttonWrapper.append(icon("link", { size: size }));
        buttonWrapper.append(span(getSizeLabel(size)));
    }
    // TODO: circle buttons
});
var dialogSection = makeComponent(function dialogSection() {
    var _this = this;
    var row = this.append(div({ className: "displayRow" }));
    var state = this.useState({ dialogOpen: false });
    var openDialog = function () {
        state.dialogOpen = true;
        _this.rerender();
    };
    var closeDialog = function () {
        state.dialogOpen = false;
        _this.rerender();
    };
    row.append(button("Open dialog", { color: "secondary", onClick: openDialog }));
    var dialogWrapper = row.append(dialog({ open: state.dialogOpen, onClose: closeDialog, closeOnClickBackdrop: true }));
    dialogWrapper.append(span("Hello world"));
});
var popupSection = makeComponent(function popupSection() {
    for (var _i = 0, _a = ["up", "right", "mouse"]; _i < _a.length; _i++) {
        var direction = _a[_i];
        var row = this.append(div({ className: "wideDisplayRow" }));
        var dialogWrapperA = row.append(popupWrapper({
            popupContent: span("Tiny"),
            direction: direction,
        }));
        dialogWrapperA.append(span("direction: \"".concat(direction, "\"")));
        var dialogWrapperB = row.append(popupWrapper({
            popupContent: span("I can be too big to naively fit on the screen!"),
            direction: direction,
        }));
        dialogWrapperB.append(span("direction: \"".concat(direction, "\"")));
    }
});
var mediaQuerySection = makeComponent(function mediaQuerySection() {
    var smOrBigger = this.useMedia({ minWidth: 600 });
    var mdOrBigger = this.useMedia({ minWidth: 900 });
    var lgOrBigger = this.useMedia({ minWidth: 1200 });
    var xlOrBigger = this.useMedia({ minWidth: 1500 });
    var column = this.append(div({ className: "displayColumn" }));
    column.append(span("smOrBigger: ".concat(smOrBigger)));
    column.append(span("mdOrBigger: ".concat(mdOrBigger)));
    column.append(span("lgOrBigger: ".concat(lgOrBigger)));
    column.append(span("xlOrBigger: ".concat(xlOrBigger)));
});
var BASIC_COMPONENT_SECTIONS = [
    {
        label: "Span",
        id: "span",
        component: spanSection,
    },
    {
        label: "Button",
        id: "button",
        component: buttonSection,
    },
    {
        label: "Icon",
        id: "icon",
        component: iconSection,
    },
    {
        label: "Dialog",
        id: "dialog",
        component: dialogSection,
    },
    {
        label: "Popup",
        id: "popup",
        component: popupSection,
    },
    {
        label: "Media query",
        id: "mediaQuery",
        component: mediaQuerySection,
    },
];
var textInputSection = makeComponent(function textInputSection() {
    var _this = this;
    var state = this.useState({ username: "" });
    // username
    var row = this.append(div({ className: "displayRow", style: { marginTop: 6 } }));
    row.append(textInput({
        label: "Username",
        value: state.username,
        onInput: function (newUsername) {
            state.username = newUsername;
            _this.rerender();
        },
        autoFocus: true,
    }));
    row.append(span("This input is stored in the component state."));
    row = this.append(div({ className: "displayRow", style: { marginTop: -4 } }));
    row.append(span("state: ".concat(JSON.stringify(state))));
    // count
    row = this.append(div({ className: "displayRow", style: { marginTop: 4 } }));
    var _a = this.useLocalStorage("count", 0), count = _a[0], setCount = _a[1];
    row.append(numberInput({
        label: "Count",
        value: count,
        onInput: function (newCount) {
            setCount(newCount === "" ? null : +newCount);
            _this.rerender();
        },
        min: 0,
        clearable: false,
    }));
    row.append(span("This input is stored in local storage (synced across tabs and components)."));
    row = this.append(div({ className: "displayRow", style: { marginTop: -4, marginBottom: 4 } }));
    row.append(span("count: ".concat(count)));
});
var tableSection = makeComponent(function tableSection() {
    var count = this.useLocalStorage("count", 0)[0];
    var rows = Array(+(count !== null && count !== void 0 ? count : 0))
        .fill(0)
        .map(function (_, i) { return i; });
    var displayRow = this.append(div({ className: "wideDisplayRow" }));
    displayRow.append(table({
        label: "Stuff",
        rows: rows,
        columns: [
            {
                label: "#",
                onRender: function (props) { return span(props.rowIndex + 1); },
            },
            {
                label: "Name",
                onRender: function (props) { return span("foo ".concat(props.row)); },
            },
            {
                label: "Count",
                onRender: function (props) { return span(props.row); },
            },
        ],
    }));
    if ((count !== null && count !== void 0 ? count : 0) % 2 === 0) {
        displayRow.append(testKeysComponent({ key: "testKeysComponent" }));
    }
});
var testKeysComponent = makeComponent(function testKeysComponent(_) {
    this.append(span(""));
});
var INPUT_SECTIONS = [
    {
        label: "Text input",
        id: "textInput",
        component: textInputSection,
    },
    {
        label: "Table",
        id: "table",
        component: tableSection,
    },
];
var MAIN_PAGE_SECTIONS = __spreadArray(__spreadArray([], BASIC_COMPONENT_SECTIONS, true), INPUT_SECTIONS, true);
var mainPage = makeComponent(function mainPage() {
    var wrapper = this.append(div({
        style: { display: "flex", flexDirection: "column", alignItems: "flex-start" },
    }));
    wrapper.append(span("version: ".concat(JSGUI_VERSION), { size: "small", selfLink: "", id: "version" }));
    for (var _i = 0, MAIN_PAGE_SECTIONS_1 = MAIN_PAGE_SECTIONS; _i < MAIN_PAGE_SECTIONS_1.length; _i++) {
        var section = MAIN_PAGE_SECTIONS_1[_i];
        wrapper.append(span(section.label, { size: "big", selfLink: section.id }));
        wrapper.append(section.component());
        // TODO!: show the code
    }
});
var notFoundPage = makeComponent(function notFoundPage() {
    this.append(span("Page not found"));
});
var root = makeComponent(function root() {
    var GITHUB_PAGES_PREFIX = "(/jsgui)?";
    this.append(router({
        pageWrapperComponent: pageWrapper,
        routes: [
            {
                path: "".concat(GITHUB_PAGES_PREFIX, "/"),
                defaultPath: "/",
                component: function () { return mainPage(); },
                wrapper: true,
                showInNavigation: true,
                label: "jsgui",
            },
        ],
        notFoundRoute: {
            component: function () { return notFoundPage(); },
        },
    }));
});
var pageWrapper = makeComponent(function pageWrapper(props) {
    var _a;
    var routes = props.routes, currentRoute = props.currentRoute, contentWrapperComponent = props.contentWrapperComponent;
    var wrapper = this.append(div({
        style: {
            height: "100%",
            display: "flex",
            alignItems: "stretch",
        },
    }));
    var navigation = wrapper.append(div({
        className: "navMenu", // TODO: styles
        style: { display: "flex", flexDirection: "column" },
    }));
    for (var _i = 0, routes_2 = routes; _i < routes_2.length; _i++) {
        var route = routes_2[_i];
        if (route.showInNavigation) {
            navigation.append(span(route.label, { href: (_a = route.defaultPath) !== null && _a !== void 0 ? _a : route.path }));
        }
    }
    // navigation.append() // TODO: divider()
    for (var _b = 0, MAIN_PAGE_SECTIONS_2 = MAIN_PAGE_SECTIONS; _b < MAIN_PAGE_SECTIONS_2.length; _b++) {
        var section = MAIN_PAGE_SECTIONS_2[_b];
        navigation.append(span(section.label, { href: "#".concat(section.id) }));
    }
    var contentWrapper = wrapper.append(contentWrapperComponent());
    contentWrapper.append(currentRoute.component());
});
renderRoot(root());
//# sourceMappingURL=docs.js.map